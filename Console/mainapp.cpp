
#include "aes.h"
#include <cstdlib>
#include <cstring>
#include <cstdio>

#define AESTEST_ASSERTION(stmt)                                     \
    do{                                                             \
        if(!stmt) {                                                 \
            printf("ASSERTION FAILED on line:%d\n",__LINE__);       \
            exit(-1);                                               \
        }                                                           \
    }while(0)


/* Example Usage */
static const char* szplaintext = "Serangan dimulai saat fajar!";
static const char* szkey       = "Janur Kuning";
static unsigned char plaintext[32];
static unsigned char decipher[32];
static unsigned char plaintext_recover[32];

/*  Test Vectors taken from 
    Recommendation for Block Cipher Modes of Operation Methods and Techniques
    Morris Dworkin

    NIST Special Publication 800-38A
    2001 Edition
*/

enum verify_t { pass,fail };

static unsigned char ecb128_key[] = {
    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 
    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
};


static unsigned char ecb128_plaintext[4][16] = {
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},
    { 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51},
    { 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef },
    { 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 }
};

static unsigned char ecb128_ciphertext[4][16] = {
    { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97 },
    { 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf },
    { 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88 },
    { 0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4 }
};


static unsigned char cbc128_initvectors[4][16] = {
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F },
    { 0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D },
    { 0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2 },
    { 0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16 }
};

static unsigned char cbc128_plaintext[4][16] = {
    { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a },
    { 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51 },
    { 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef },
    { 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 }
};

static unsigned char cbc128_ciphertext[4][16] = {
    { 0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46, 0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d },
    { 0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee, 0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2 },
    { 0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b, 0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16 },
    { 0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09, 0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7 }

};

/* Test vector untuk AES-CMAC */
/*  
   --------------------------------------------------
   M              <empty string>
   AES-CMAC       bb1d6929 e9593728 7fa37d12 9b756746
   --------------------------------------------------
*/
static unsigned char aescmacex1_result[16] = {
    0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28, 
    0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46
};


/*
   Example 2: len = 16
   M              6bc1bee2 2e409f96 e93d7e11 7393172a
   AES-CMAC       070a16b4 6b4d4144 f79bdd9d d04a287c
   --------------------------------------------------
*/
static unsigned char aescmacex2_m[] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
};

static unsigned char aescmacex2_result[16] = {
    0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44, 
    0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c
};

/*
   Example 3: len = 40
   M              6bc1bee2 2e409f96 
                  e93d7e11 7393172a
                  ae2d8a57 1e03ac9c 
                  9eb76fac 45af8e51
                  30c81c46 a35ce411
   
   AES-CMAC       dfa66747 de9ae630 
                  30ca3261 1497c827
   --------------------------------------------------
*/
static unsigned char aescmacex3_m[] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51, 
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11
};

static unsigned char aescmacex3_result[16] = {
    0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30, 
    0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27
};

/*
   Example 4: len = 64
   M              6bc1bee2 2e409f96 e93d7e11 7393172a
                  ae2d8a57 1e03ac9c 9eb76fac 45af8e51
                  30c81c46 a35ce411 e5fbc119 1a0a52ef
                  f69f2445 df4f9b17 ad2b417b e66c3710
   AES-CMAC       51f0bebf 7e3b9d92 fc497417 79363cfe
   --------------------------------------------------
*/
static unsigned char aescmacex4_m[] = {
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};

static unsigned char aescmacex4_result[16] = {
    0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92, 
    0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe
};

/* AES structure for all aes operation */
static AES128 aes;

static verify_t verify_vector(unsigned char* arr_a,unsigned char* arr_b,int len)
{
    for(int idx=0;idx<len;++idx)
    {
        if((arr_a[idx] ^ arr_b[idx]) != 0 )
            return fail;
    }
    return pass;
}

static verify_t test_ecb_vectors(void)
{
    static unsigned char resultdata[16];
    memcpy(aes.aeskey,ecb128_key,sizeof(ecb128_key));
    aes.aes_mode = AES_MODE_ECB;
    // test encrypt
    for(int idx=0;idx < 4 ;++idx)
    {
        aes.p_input  = ecb128_plaintext[idx];
        aes.inlength = 16;
        aes.p_output = resultdata;
        aes.outlength = sizeof(resultdata);
        aes128_encipher(&aes);
        if(verify_vector(resultdata,ecb128_ciphertext[idx],16) == fail)
            return fail;
    }

    // test decrypt
    for(int idx=0;idx<4;++idx)
    {
        aes.p_input  = ecb128_ciphertext[idx];
        aes.inlength = 16;
        aes.p_output = resultdata;
        aes.outlength = sizeof(resultdata);
        aes128_decipher(&aes);
        if(verify_vector(resultdata,ecb128_plaintext[idx],16) == fail)
            return fail;
    }

    return pass;
}




static verify_t test_cbc_vectors()
{
    static unsigned char resultdata[16];
    memcpy(aes.aeskey,ecb128_key,sizeof(ecb128_key));
    aes.aes_mode = AES_MODE_CBC;
    // test encrypt
    for(int idx=0;idx < 4 ;++idx)
    {
        memcpy(aes.initvector,cbc128_initvectors[idx],16);
        aes.p_input  = cbc128_plaintext[idx];
        aes.inlength = 16;
        aes.p_output = resultdata;
        aes.outlength = sizeof(resultdata);
        aes128_encipher(&aes);
        if(verify_vector(resultdata,cbc128_ciphertext[idx],16) == fail)
            return fail;
    }

    // test decrypt
    for(int idx=0;idx<4;++idx)
    {
        memcpy(aes.initvector,cbc128_initvectors[idx],16);
        aes.p_input  = cbc128_ciphertext[idx];
        aes.inlength = 16;
        aes.p_output = resultdata;
        aes.outlength = sizeof(resultdata);
        aes128_decipher(&aes);
        if(verify_vector(resultdata,cbc128_plaintext[idx],16) == fail)
            return fail;
    }

    return pass;

}



static void example_usage(void)
{
    memcpy(aes.aeskey,szkey,16);
    memset(aes.initvector,0xDF,16);
    strcpy_s((char*)plaintext,strlen(szplaintext),szplaintext);
    aes.p_input = plaintext;
    aes.inlength= strlen(szplaintext);
    aes.p_output = decipher;
    aes.outlength = sizeof(decipher);
    aes.aes_mode = AES_MODE_CBC;

    aes128_encipher(&aes);

    aes.p_input = decipher;
    aes.inlength = sizeof(decipher);
    aes.p_output = plaintext_recover;
    aes.outlength=sizeof(plaintext_recover);
    aes128_decipher(&aes);

}

int main(){
#ifdef EXAMPLE_USAGE
    example_usage();
#endif
    verify_t result =  test_ecb_vectors();
    AESTEST_ASSERTION(result == pass);
    result = test_cbc_vectors();
    AESTEST_ASSERTION(result == pass);
    printf("TEST AES128 CBC AND ECB PASS\n");
    
    /* testing AES CMAC */
    static unsigned char aescmac[16];
    memcpy(aes.aeskey,ecb128_key,16);
    aes.p_output = aescmac;
    aes.outlength = 16;

    aes.p_input = aescmacex3_m;
    aes.inlength = sizeof(aescmacex3_m);
    aescmac_generate(&aes);
    AESTEST_ASSERTION(verify_vector(aes.p_output,aescmacex3_result,16) == pass);

    aes.p_input = aescmacex2_m;
    aes.inlength = sizeof(aescmacex2_m);
    aescmac_generate(&aes);
    AESTEST_ASSERTION(verify_vector(aes.p_output,aescmacex2_result,16) == pass);

    aes.p_input = aescmacex4_m;
    aes.inlength = sizeof(aescmacex4_m);
    aescmac_generate(&aes);
    AESTEST_ASSERTION(verify_vector(aes.p_output,aescmacex4_result,16) == pass);
    printf("TESTING AES CMAC : PASS\n");
    return 0;
}